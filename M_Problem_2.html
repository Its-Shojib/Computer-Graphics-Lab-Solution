<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Line Clipping</title>
    <style>
        canvas {
            border: 1px solid black;
            display: block;
            margin: 10px 0;
        }
        form {
            margin: 10px 0;
        }
        .flex {
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 20px;
        }
    </style>
</head>
<body class="flex">
    <canvas id="glcanvas" width="500" height="500"></canvas>
    <form id="lineForm">
        <label for="x1">x1:</label>
        <input type="number" id="x1" name="x1" required>
        <label for="y1">y1:</label>
        <input type="number" id="y1" name="y1" required>
        <label for="x2">x2:</label>
        <input type="number" id="x2" name="x2" required>
        <label for="y2">y2:</label>
        <input type="number" id="y2" name="y2" required>
        <button type="button" onclick="clipAndDrawLine()">Clip Line</button>
    </form>
    <script>
        const vertexShaderSource = `
            attribute vec2 aPosition;
            void main() {
                gl_Position = vec4(aPosition, 0.0, 1.0);
            }
        `;

        const fragmentShaderSource = `
            void main() {
                gl_FragColor = vec4(1.0, 1.0, 1.0, 1.0);
            }
        `;
        let gl;
        let program;
        let positionBuffer;

        // WebGL initialization
        function initWebGL() {
            const canvas = document.getElementById('glcanvas');
            gl = canvas.getContext('webgl');
            if (!gl) {
                alert('WebGL not supported, falling back on experimental-webgl');
                gl = canvas.getContext('experimental-webgl');
            }
            if (!gl) {
                alert('Your browser does not support WebGL');
            }

            const vertexShader = createShader(gl, gl.VERTEX_SHADER, vertexShaderSource);
            const fragmentShader = createShader(gl, gl.FRAGMENT_SHADER, fragmentShaderSource);
            program = createProgram(gl, vertexShader, fragmentShader);

            gl.useProgram(program);
            const aPosition = gl.getAttribLocation(program, 'aPosition');
            positionBuffer = gl.createBuffer();
            gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
            gl.enableVertexAttribArray(aPosition);
            gl.vertexAttribPointer(aPosition, 2, gl.FLOAT, false, 0, 0);

            gl.clearColor(0.0, 0.0, 0.0, 1.0);
        }

        function createShader(gl, type, source) {
            const shader = gl.createShader(type);
            gl.shaderSource(shader, source);
            gl.compileShader(shader);
            if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                console.error('Shader compile failed with: ' + gl.getShaderInfoLog(shader));
                gl.deleteShader(shader);
                return null;
            }
            return shader;
        }

        function createProgram(gl, vertexShader, fragmentShader) {
            const program = gl.createProgram();
            gl.attachShader(program, vertexShader);
            gl.attachShader(program, fragmentShader);
            gl.linkProgram(program);
            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
                console.error('Program failed to link: ' + gl.getProgramInfoLog(program));
                gl.deleteProgram(program);
                return null;
            }
            return program;
        }

        // Function to calculate region code for a point (x, y) with respect to the clipping window
        function computeRegionCode(x, y, xmin, xmax, ymin, ymax) {
            let code = 0;
            if (x < xmin)      // to the left of clip window
                code |= 1;
            else if (x > xmax) // to the right of clip window
                code |= 2;
            if (y < ymin)      // below the clip window
                code |= 4;
            else if (y > ymax) // above the clip window
                code |= 8;
            return code;
        }


        // Function to clip a line segment using Cohen-Sutherland algorithm
        function cohenSutherlandLineClip(x1, y1, x2, y2, xmin, xmax, ymin, ymax) {
            let code1 = computeRegionCode(x1, y1, xmin, xmax, ymin, ymax);
            let code2 = computeRegionCode(x2, y2, xmin, xmax, ymin, ymax);

            let accept = false;
            let done = false;

            while (!done) {
                if ((code1 === 0) && (code2 === 0)) {
                    accept = true;
                    done = true;
                } else if (code1 & code2) {
                    done = true;
                } else {
                    let x, y;
                    let codeOut = (code1 !== 0) ? code1 : code2;

                    if (codeOut & 8) {          // top
                        x = x1 + (x2 - x1) * (ymax - y1) / (y2 - y1);
                        y = ymax;
                    } else if (codeOut & 4) {   // bottom
                        x = x1 + (x2 - x1) * (ymin - y1) / (y2 - y1);
                        y = ymin;
                    } else if (codeOut & 2) {   // right
                        y = y1 + (y2 - y1) * (xmax - x1) / (x2 - x1);
                        x = xmax;
                    } else if (codeOut & 1) {   // left
                        y = y1 + (y2 - y1) * (xmin - x1) / (x2 - x1);
                        x = xmin;
                    }

                    if (codeOut === code1) {
                        x1 = x;
                        y1 = y;
                        code1 = computeRegionCode(x1, y1, xmin, xmax, ymin, ymax);
                    } else {
                        x2 = x;
                        y2 = y;
                        code2 = computeRegionCode(x2, y2, xmin, xmax, ymin, ymax);
                    }
                }
            }

            if (accept) {
                return [x1, y1, x2, y2];
            } else {
                return null;
            }
        }

        // Function to draw a line segment on WebGL canvas
        function drawLine(gl, points) {
            const normalizedPoints = points.map((v, i) => {
                if (i % 2 === 0) {
                    return (v / (gl.canvas.width / 2)) - 1;
                } else {
                    return 1 - (v / (gl.canvas.height / 2));
                }
            });

            gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(normalizedPoints), gl.STATIC_DRAW);
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawArrays(gl.LINE_STRIP, 0, 2);
        }

        // Function to handle line clipping and drawing
        function clipAndDrawLine() {
            const x1 = parseInt(document.getElementById('x1').value);
            const y1 = parseInt(document.getElementById('y1').value);
            const x2 = parseInt(document.getElementById('x2').value);
            const y2 = parseInt(document.getElementById('y2').value);

            initWebGL();

            const clippedLine = cohenSutherlandLineClip(x1, y1, x2, y2, 100, 400, 100, 400); // Example clipping window: (100, 100) to (400, 400)

            if (clippedLine) {
                drawLine(gl, clippedLine);
            } else {
                console.log('Line segment completely outside the clipping window.');
            }
        }
    </script>
</body>
</html>
